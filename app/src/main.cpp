//
// Created by Administrator on 3/28/2024.
//

extern "C"
{
	#include <lib.h>
}

#include <chrono>
#include <limits.h>
#include <string>
#include <sstream>
#include <map>
#include <iostream>

typedef std::chrono::nanoseconds nanosecs;

/// returns the unix time in nanoseconds
nanosecs now();

/// returns how long it takes for a given key to be compared to the right key by the lib, in nanoseconds
nanosecs time_key(std::string key);

/// returns the char that took the most time to get compared with the lib's key when appended to the given key
char find_longest_next_char_once(std::string key);

/// runs find_longest_next_char_once() *iterations* times for every possible char and returns the char with the best score
char find_longest_next_char_mult(std::string key, int iterations = 10);

/// creates a key and appends the result of find_longest_next_char_once() to it until the lib approves it
std::string determine_key();

int main()
{	lib_generate_key();
	std::string key = determine_key();
	std::cout << "key : " << key;
}

nanosecs now()
{	return std::chrono::duration_cast<nanosecs>(std::chrono::system_clock::now().time_since_epoch());
}

nanosecs time_key(std::string key)
{	nanosecs prev = now();
	lib_try_key((char *)key.c_str());
	return now() - prev;
}

char find_longest_next_char_once(std::string key)
{	std::map<char, nanosecs> results = { { '\0', {} } };
	int i = key.length();
	key.append(" ");
	// time all possible chars
	for(char c = CHAR_MIN; c < CHAR_MAX; ++c)
	{	key[i] = c;
		key[i] += !key[i];
		results[c] = time_key((char *)key.c_str());
	}
	// return the longest recorded char
	char longest_char = CHAR_MIN;
	nanosecs longest_time = results[longest_char];
	for(char c = longest_char + 1; c < CHAR_MAX; ++c)
		if(results[c] > longest_time)
		{	longest_char = c;
			longest_time = results[c];
		}
	return longest_char;
}

char find_longest_next_char_mult(std::string key, int iterations)
{	// char-score map
	std::map<char, int> scores;
	// set all scores to 0
	for(char c = CHAR_MIN; c < CHAR_MAX; ++c)
		scores[c] = 0;
	// register scores
	for(int i = 0; i < iterations; ++i)
		++scores[find_longest_next_char_once(key)];
	// find the best score
	char best_char = '\0';
	char best_score = 0;
	for(char c = CHAR_MIN; c < CHAR_MAX; ++c)
		if(scores[c] > best_score)
		{	best_char = c;
			best_score = scores[c];
		}
	return best_char;
}

std::string determine_key()
{	std::string key;
	for(;;)
	{	char next = find_longest_next_char_mult(key);
		key.append(" ");
		std::cout << "current brute key length : " << key.length() << std::endl;
		key[key.length() - 1] = next;
		if(lib_try_key((char *)key.c_str()))
			return key;
	}
}
